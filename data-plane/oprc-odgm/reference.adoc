= OPRC API Reference
:toc:
:toc-placement: preamble
:toclevels: 2

// Need some preamble to get TOC:
{empty}

== Overview

This document describes the API for the Object as a Service (OAAS) system using the Object Platform Runtime Core (OPRC). 

[TIP]
====
Checklist markers indicate implementation status:

* `[x]` — operation is implemented and available.
* `[ ]` — operation is planned but not yet implemented.
====

The system provides two main interfaces:
- *Gateway REST API*: HTTP-based interface for external clients
- *Zenoh API*: High-performance pub/sub interface for internal communication

Key concepts:
- *Classes*: Define object types and their methods
- *Partitions*: Logical groupings for scalability (0-65535) 
- *Objects*: Instances of classes with unique IDs
- *Methods*: Functions that can be invoked on objects or as stateless operations

== Gateway REST API

The Gateway provides a standard HTTP REST interface for external clients.

=== Function Invocation

Execute methods either on specific objects (stateful) or as standalone functions (stateless).

* [x] *POST* `/api/class/<class>/<partition>/objects/<object_id>/invokes/<method_id>`
+
Invoke a method on a specific object instance
+
- Executes the method in the context of the object's state
- Returns the result synchronously

* [x] *POST* `/api/class/<class>/<partition>/invokes/<method_id>`
+
Invoke a stateless method
+
- Executes the method without object context
- Returns the result synchronously

=== Object Management

Manage object lifecycle and data persistence.

* [x] *GET* `/api/class/<class>/<partition>/objects/<object_id>`
+
Retrieve an object from storage
+
NOTE: `<object_id>` accepts either a numeric identifier or a normalized string
identifier. String IDs must be URL encoded when they include reserved
characters; the gateway normalizes them before persistence.

Response: <<ObjData,ObjData>>

* [x] *PUT* `/api/class/<class>/<partition>/objects/<object_id>`
+
Store or update an object
+
NOTE: `<object_id>` supports both numeric and string forms. String IDs are
validated against the limits described in the string-based IDs proposal before
being written.

Request: <<ObjData,ObjData>>
+
Response: Empty (204 No Content)

== Zenoh API

High-performance publish/subscribe interface used internally by the system. Uses Zenoh's key-value expressions for routing.

=== Synchronous Invocations

Request-response pattern using Zenoh queries (GET operations).

* [x] *GET* `oprc/<class>/<partition>/invokes/<method_id>`
+
Execute a stateless method and wait for result
+
Request: <<InvocationRequest,InvocationRequest>>
+
Response: <<InvocationResponse,InvocationResponse>>

* [x] *GET* `oprc/<class>/<partition>/objects/<object_id>/invokes/<method_id>`
+
Execute a method on an object and wait for result
+
Request: <<ObjectInvocationRequest,ObjectInvocationRequest>>
+
Response: <<InvocationResponse,InvocationResponse>>

=== Asynchronous Invocations

Fire-and-forget pattern using Zenoh publishers (PUT operations). Results are available separately.

* [x] *PUT* `oprc/<class>/<partition>/invokes/<method_id>/async/<invocation_id>`
+
Execute a stateless method asynchronously
+
- Returns immediately without waiting for execution
- Use `invocation_id` to retrieve results later
+
Request: <<InvocationRequest,InvocationRequest>>

* [x] *PUT* `oprc/<class>/<partition>/objects/<object_id>/invokes/<method_id>/async/<invocation_id>`
+
Execute a method on an object asynchronously
+
Request: <<ObjectInvocationRequest,ObjectInvocationRequest>>

=== Asynchronous Result Retrieval

Access results from asynchronous invocations.

* [x] *GET/SUB* `oprc/<class>/<partition>/results/<method_id>/async/<invocation_id>`
+
Get or subscribe to results of asynchronous stateless invocation
+
- GET: Retrieve result once if available
- SUB: Subscribe to be notified when result becomes available
+
Response: <<InvocationResponse,InvocationResponse>>

* [x] *GET/SUB* `oprc/<class>/<partition>/objects/<object_id>/results/<method_id>/async/<invocation_id>`
+
Get or subscribe to results of asynchronous object method invocation
+
Response: <<InvocationResponse,InvocationResponse>>


=== Object Storage Operations

Direct object manipulation in the distributed storage layer.

NOTE: All occurrences of `<object_id>` in the Zenoh keys below accept either a
numeric ID or a normalized string ID. String identifiers should be escaped when
used in Zenoh key expressions; the ODGM layer performs the same normalization
as the REST gateway.

* [x] *PUT* `oprc/<class>/<partition>/objects/<object_id>`
+
Store an object (fire-and-forget)
+
- Does not wait for persistence confirmation
+
Payload: <<ObjData,ObjData>>

* [x] *GET* `oprc/<class>/<partition>/objects/<object_id>/set`
+
Store an object and wait for persistence
+
- Blocks until object is safely persisted
- Use when consistency is critical
+
Payload: <<ObjData,ObjData>>

* [x] *GET* `oprc/<class>/<partition>/objects/<object_id>/batch-set`
+
Atomically upsert or delete multiple entries and wait for persistence
+
- Accepts mixed inserts/updates (`values`) and tombstone deletes (`delete_keys`)
- Optional compare-and-swap guard via `expected_object_version`
- Blocks until the batch is applied or rejected (version mismatch ⇒ error)
+
NOTE: Requires string object identifiers and granular entry storage to be enabled for the target shard.

Payload: <<BatchSetValuesRequest,BatchSetValuesRequest>>

Response: <<EmptyResponse,EmptyResponse>>

* [x] *GET* `oprc/<class>/<partition>/objects/<object_id>`
+
Retrieve an object from storage
+
Response: <<ObjData,ObjData>>

* [x] *GET* `oprc/<class>/<partition>/objects/<object_id>/entries/<key>`
+
Retrieve a specific entry from an object
+
- More efficient than fetching entire object
+
NOTE: Returns <<ValueResponse,ValueResponse>> with `object_version` populated when granular storage is active.
+
Response: <<ValueResponse,ValueResponse>>

* [x] *DELETE* `oprc/<class>/<partition>/objects/<object_id>`
+
Remove an object from storage

=== Advanced Object Operations

Additional operations for complex data manipulation.

* [ ] *PUT* `oprc/<class>/<partition>/objects/<object_id>/merge`
+
Merge data into an existing object
+
- Combines new data with existing object state
+
Payload: <<ObjData,ObjData>>

* [ ] *GET* `oprc/<class>/<partition>/objects/<object_id>/merge`
+
Merge data and return the result
+
- Atomic merge operation with immediate result
+
Request: <<ObjData,ObjData>>
+
Response: <<ObjData,ObjData>>


* [ ] *SUB* `oprc/<class>/<partition>/objects/<object_id>/changes`
+
Subscribe to object change notifications
+
- Real-time updates when object is modified
+
Response: <<ObjData,ObjData>>

=== Event System

Pure asynchronous trigger execution for reactive applications. Events are automatically triggered by object operations and dispatched via Zenoh's fire-and-forget mechanism.

==== Event Triggering (Internal)

Events are triggered automatically by the system - no direct API calls needed.

* [x] *Internal Event Detection*
+
Data change events (create/update/delete) are automatically detected during:
+
- Object storage operations (`PUT`, `DELETE`)
- Field-level data modifications
- Object lifecycle changes
+
Function events (complete/error) are triggered during:
+
- Method invocation completion
- Exception handling
- Timeout scenarios

==== Trigger Execution (Internal)

Triggers execute asynchronously via Zenoh PUT operations with no result tracking.

* [x] *Automatic PUT* `oprc/<class>/<partition>/async/<method_id>/<invocation_id>`
+
Execute stateless trigger function asynchronously
+
- Triggered automatically by configured events
- Fire-and-forget execution (no response)
- Uses <<TriggerPayload,TriggerPayload>> as request payload

* [x] *Automatic PUT* `oprc/<class>/<partition>/objects/<object_id>/async/<method_id>/<invocation_id>`
+
Execute stateful trigger method asynchronously
+
- Triggered automatically by configured events
- Fire-and-forget execution (no response)  
- Uses <<TriggerPayload,TriggerPayload>> as request payload

==== Event Configuration

Events are configured via the `ObjectEvent` field in <<ObjData,ObjData>>.

* *Data Events*: Triggered on object field changes
+
[source,yaml]
----
# Example: Field 42 triggers notification on update
data_trigger:
  42:
    on_update:
      - cls_id: "notification_service"
        partition_id: 0
        fn_id: "send_notification"
----

* *Function Events*: Triggered on method completion/error
+
[source,yaml]
----
# Example: Function triggers audit logging
func_trigger:
  "my_function":
    on_complete:
      - cls_id: "audit_service"
        partition_id: 1
        fn_id: "log_completion"
    on_error:
      - cls_id: "error_service"
        partition_id: 2
        fn_id: "handle_error"
----

==== Performance Characteristics

* *Event Detection*: O(1) field comparison per changed field
* *Trigger Matching*: O(1) hash map lookup per event type
* *Trigger Execution*: Zero-overhead Zenoh PUT operation
* *Memory Footprint*: Minimal - no result tracking or monitoring
* *Concurrency*: Unlimited concurrent trigger execution

=== Capabilities (per-shard over Zenoh)

Expose shard capabilities for data-plane discovery via Zenoh queryables.

* [x] *GET* `oprc/<class>/<partition>/shards/<shard_id>/capabilities`
+
Return a JSON document describing the current shard capabilities on this ODGM instance.
+
Response (application/json):
+
[source,json]
----
{
  "class": "<class>",
  "partition": 0,
  "shard_id": 12345,
  "event_pipeline_v2": true,
  "storage_backend": "fjall",
  "odgm_version": "0.1.0",
  "features": {
    "granular_storage": true,
    "bridge_mode": false
  }
}
----

Notes:
- This endpoint is per-shard and per-instance; aggregation across shards or instances should be implemented by the caller using Zenoh query fanout.
- Enable/disable service via env `ODGM_CAPS_QUERYABLE_ENABLED` (default: true).

=== Consensus Protocol (Raft)

Internal cluster communication for distributed consensus.

* [x] *GET* `oprc/<class>/<partition>/raft-append/<replica_id>`
+
Raft AppendEntries RPC
+
- Log replication and heartbeat messages

* [x] *GET* `oprc/<class>/<partition>/raft-vote/<replica_id>`
+
Raft RequestVote RPC
+
- Leader election process

* [x] *GET* `oprc/<class>/<partition>/raft-snapshot/<replica_id>`
+
Raft InstallSnapshot RPC
+
- Efficient state transfer for lagging replicas

* [x] *GET* `oprc/<class>/<partition>/ops/<replica_id>`
+
Send operation to specific replica
+
- Direct replica communication

== Data Structures

=== Path Parameters

URL path components and their data types:

[cols="2,2,4"]
|===
|Parameter |Type |Description

|`class` |string |Class identifier (object type)
|`partition` |uint16 |Partition number (0-65535)
|`object_id` |uint64 \| string |Unique object identifier (numeric or normalized string)
|`method_id` |string |Method/function name
|`field_id` |uint16 |Object field identifier
|`replica_id` |uint64 |Replica node identifier
|`invocation_id` |string |Unique invocation identifier for async calls
|===

IMPORTANT: Protobuf does not natively support uint16. Values must fit within the range when encoded.

=== Message Types

Protocol buffer definitions for API data structures.

==== Object Data

* [[ObjData]] *ObjData* - Complete object representation
+
[source,protobuf]
----
message ObjData {
  optional ObjMeta metadata = 1;     // Object metadata
  map<uint32, ValData> entries = 2;  // Field data by field ID
  map<string, ValData> entries_str = 4; // String-keyed field data
  optional ObjectEvent event = 3;    // Event triggers for the object
}
----

* [[ObjMeta]] *ObjMeta* - Object metadata
+
[source,protobuf]
----
message ObjMeta {
  string cls_id = 1;        // Class identifier
  uint32 partition_id = 2;  // Partition number
  uint64 object_id = 3;     // Object identifier (numeric)
  optional string object_id_str = 4; // String identifier (mutually exclusive with object_id)
}
----

* [[ValData]] *ValData* - Field value data
+
[source,protobuf]
----
message ValData {
  bytes data = 1;    // Raw data content
  ValType type = 2;  // Data type indicator
}

enum ValType {
  VAL_TYPE_BYTE = 0;      // Raw byte data
  VAL_TYPE_CRDT_MAP = 1;  // CRDT (Conflict-free Replicated Data Type) data
}
----

* [[ValueResponse]] *ValueResponse* - Single entry lookup response
+
[source,protobuf]
----
message ValueResponse {
  ValData value = 1;                 // Entry payload when present
  optional uint64 object_version = 2; // Monotonic version (set when granular storage enabled)
  optional string key = 3;           // Canonical key (numeric keys encoded as decimal strings)
  optional bool deleted = 4;         // True when the entry is a tombstone rather than missing
}
----

==== Invocation Messages

* [[InvocationRequest]] *InvocationRequest* - Stateless function call
+
[source,protobuf]
----
message InvocationRequest {
    uint32 partition_id = 1;              // Partition number
    string cls_id = 3;                    // Class identifier
    string fn_id = 4;                     // Function/method name
    map<string, string> options = 5;      // Execution options
    bytes payload = 6;                    // Function parameters
}
----

* [[ObjectInvocationRequest]] *ObjectInvocationRequest* - Object method call
+
[source,protobuf]
----
message ObjectInvocationRequest {
    uint32 partition_id = 1;              // Partition number
    uint64 object_id = 2;                 // Target object ID
    string cls_id = 3;                    // Class identifier
    string fn_id = 4;                     // Method name
    map<string, string> options = 5;      // Execution options
    bytes payload = 6;                    // Method parameters
}
----

* [[InvocationResponse]] *InvocationResponse* - Function/method result
+
[source,protobuf]
----
message InvocationResponse {
    optional bytes payload = 1;           // Return value
    ResponseStatus status = 2;            // Execution status
    map<string, string> headers = 3;      // Response headers
    string invocation_id = 4;             // Unique invocation identifier
}

enum ResponseStatus {
    OKAY = 0;            // Success
    INVALID_REQUEST = 1; // Invalid request format or parameters
    APP_ERROR = 2;       // Application-level error during execution
    SYSTEM_ERROR = 3;    // System-level error (infrastructure, network, etc.)
}
----

==== Additional Message Types

* [[ObjectEvent]] *ObjectEvent* - Event triggers for objects
+
[source,protobuf]
----
message ObjectEvent {
  map<string, FuncTrigger> func_trigger = 1;   // Function-based triggers
  map<uint32, DataTrigger> data_trigger = 2;   // Data-based triggers
  map<string, DataTrigger> data_trigger_str = 3; // String-keyed data triggers
}
----

* [[FuncTrigger]] *FuncTrigger* - Function execution triggers

* [[SingleObjectRequest]] *SingleObjectRequest* - Object identity helper
+
[source,protobuf]
----
message SingleObjectRequest {
  string cls_id = 1;             // Class identifier
  uint32 partition_id = 2;       // Partition number
  uint64 object_id = 3;          // Numeric identifier
  optional string object_id_str = 4; // Normalized string identifier (exclusive with object_id)
}
----

* [[SingleKeyRequest]] *SingleKeyRequest* - Entry identity helper
+
[source,protobuf]
----
message SingleKeyRequest {
  string cls_id = 1;
  uint32 partition_id = 2;
  uint64 object_id = 3;
  uint32 key = 4;
  optional string key_str = 5;        // String-keyed entry (exclusive with key)
  optional string object_id_str = 6;  // String object identifier (exclusive with object_id)
}
----

* [[SetKeyRequest]] *SetKeyRequest* - Single entry mutation
+
[source,protobuf]
----
message SetKeyRequest {
  string cls_id = 1;
  int32 partition_id = 2;
  uint64 object_id = 3;
  uint32 key = 4;
  ValData value = 5;
  optional string key_str = 6;        // String-keyed entry (exclusive with key)
  optional string object_id_str = 7;  // String object identifier (exclusive with object_id)
}
----

* [[SetObjectRequest]] *SetObjectRequest* - Full object mutation
+
[source,protobuf]
----
message SetObjectRequest {
  string cls_id = 1;
  int32 partition_id = 2;
  uint64 object_id = 3;
  ObjData object = 4;
  optional string object_id_str = 5;  // String object identifier (exclusive with object_id)
}
----

* [[BatchSetValuesRequest]] *BatchSetValuesRequest* - Atomic entry batch
+
[source,protobuf]
----
message BatchSetValuesRequest {
  string cls_id = 1;
  uint32 partition_id = 2;
  uint64 object_id = 3;
  optional string object_id_str = 4;
  map<string, ValData> values = 5;          // Entries to upsert (numeric keys encoded as strings)
  repeated string delete_keys = 6;          // Keys to tombstone in the same batch
  optional uint64 expected_object_version = 7; // CAS guard; ABORTED on mismatch
}
----

* [[ListValuesRequest]] *ListValuesRequest* - Entry enumeration request
+
[source,protobuf]
----
message ListValuesRequest {
  string cls_id = 1;
  uint32 partition_id = 2;
  uint64 object_id = 3;
  optional string object_id_str = 4;
  optional string key_prefix = 5;   // Optional string prefix filter
  uint32 limit = 6;                 // Page size (server may cap)
  optional bytes cursor = 7;        // Opaque resume token
}
----

* [[ValueEnvelope]] *ValueEnvelope* - Streamed entry payload
+
[source,protobuf]
----
message ValueEnvelope {
  string key = 1;                 // Canonical entry key (numeric encoded as string)
  optional ValData value = 2;     // Entry value when present (absent indicates tombstone)
  uint64 version = 3;             // Object version when this entry last changed
  optional bytes next_cursor = 4; // Pagination token for follow-up queries
}
----
+
[source,protobuf]
----
message FuncTrigger {
  repeated TriggerTarget on_complete = 1;  // Triggers on successful completion
  repeated TriggerTarget on_error = 2;     // Triggers on error
}
----
  EventInfo event_info = 1;              // Event context information
  optional bytes original_payload = 3;   // Original data that triggered the event
+
[source,protobuf]
----
message DataTrigger {
  repeated TriggerTarget on_create = 1;  // Triggers on data creation
  repeated TriggerTarget on_update = 2;  // Triggers on data update
  repeated TriggerTarget on_delete = 3;  // Triggers on data deletion
}
----

* [[TriggerTarget]] *TriggerTarget* - Target for trigger execution
  EventType event_type = 4;         // Event type (see EventType enum)
[source,protobuf]
----
message TriggerTarget {
  string cls_id = 1;                      // Target class
  uint32 partition_id = 2;                // Target partition
  optional uint64 object_id = 3;          // Target object (if applicable)
  string fn_id = 4;                       // Target function
  map<string, string> req_options = 5;    // Request options
}
----

* [[FuncInvokeRoute]] *FuncInvokeRoute* - Function routing configuration
+
[source,protobuf]
----
message FuncInvokeRoute {
  string url = 1;                   // Function endpoint URL
  bool stateless = 2;               // Whether function is stateless
  bool standby = 3;                 // Whether this is a standby route
  repeated uint64 active_group = 4; // Active replica group
}
----

==== Event System Messages

* [[TriggerPayload]] *TriggerPayload* - Event trigger execution payload
+
[source,protobuf]
----
message TriggerPayload {
  optional EventInfo event_info = 1;     // Event context information
  optional bytes original_payload = 2;   // Original data that triggered the event
}
----

* [[EventInfo]] *EventInfo* - Event context metadata
+
[source,protobuf]
----
message EventInfo {
  string source_cls_id = 1;        // Source object class
  uint32 source_partition_id = 2;  // Source object partition
  uint64 source_object_id = 3;     // Source object ID
  int32 event_type = 4;             // Event type (see EventType enum)
  optional string fn_id = 5;        // Function ID (for function events)
  optional uint32 key = 6;          // Field ID (for data events)
  uint64 timestamp = 7;             // Event timestamp (milliseconds since epoch)
  map<string, string> context = 8; // Additional event context
}

enum EventType {
  EVENT_TYPE_UNKNOWN = 0;          // Reserved/unspecified
  EVENT_TYPE_FUNC_COMPLETE = 1;    // Function completed successfully
  EVENT_TYPE_FUNC_ERROR = 2;       // Function completed with error
  EVENT_TYPE_DATA_CREATE = 3;      // Data field was created
  EVENT_TYPE_DATA_UPDATE = 4;      // Data field was updated
  EVENT_TYPE_DATA_DELETE = 5;      // Data field was deleted
}
----
